{
  "entities": {
    "BlogPost": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "BlogPost",
      "type": "object",
      "description": "Represents a blog post with its content, metadata, and relationships.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the blog post. (Primary Key)"
        },
        "title": {
          "type": "string",
          "description": "Title of the blog post."
        },
        "slug": {
          "type": "string",
          "description": "Slug for the blog post, used in the URL."
        },
        "authorId": {
          "type": "string",
          "description": "Reference to the Author of the blog post. (Relationship: Author 1:N BlogPost)"
        },
        "content": {
          "type": "string",
          "description": "The main content of the blog post, likely stored as HTML or Markdown."
        },
        "coverImage": {
          "type": "string",
          "description": "URL or path to the cover image for the blog post."
        },
        "publicationDate": {
          "type": "string",
          "description": "Date and time when the blog post was published.",
          "format": "date-time"
        },
        "tagIds": {
          "type": "array",
          "description": "References to Tags associated with the blog post. (Relationship: Tag N:N BlogPost)",
          "items": {
            "type": "string"
          }
        },
        "summary": {
          "type": "string",
          "description": "A short summary of the blog post generated by Gemini API."
        }
      },
      "required": [
        "id",
        "title",
        "slug",
        "authorId",
        "content",
        "coverImage",
        "publicationDate",
        "summary"
      ]
    },
    "Author": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Author",
      "type": "object",
      "description": "Represents an author (admin) who can create blog posts.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the author. (Primary Key)"
        },
        "name": {
          "type": "string",
          "description": "Name of the author."
        },
        "bio": {
          "type": "string",
          "description": "A short biography of the author."
        },
        "profileImage": {
          "type": "string",
          "description": "URL or path to the author's profile image."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "Tag": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Tag",
      "type": "object",
      "description": "Represents a tag that can be associated with blog posts.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the tag. (Primary Key)"
        },
        "name": {
          "type": "string",
          "description": "Name of the tag."
        }
      },
      "required": [
        "id",
        "name"
      ]
    },
    "SiteConfiguration": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "SiteConfiguration",
      "type": "object",
      "description": "Represents site-wide configuration settings.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the site configuration. (Primary Key). Should only ever be one record."
        },
        "primaryColor": {
          "type": "string",
          "description": "Primary color of the site (e.g., Soft Lavender)."
        },
        "backgroundColorLight": {
          "type": "string",
          "description": "Background color of the site in light mode (e.g., Off-White)."
        },
        "backgroundColorDark": {
          "type": "string",
          "description": "Background color of the site in dark mode (e.g., Dark Gray)."
        },
        "accentColor": {
          "type": "string",
          "description": "Accent color of the site (e.g., Dusty Rose)."
        },
        "headlineFont": {
          "type": "string",
          "description": "Font family for headlines (e.g., 'Belleza')."
        },
        "bodyFont": {
          "type": "string",
          "description": "Font family for body text (e.g., 'Alegreya')."
        }
      },
      "required": [
        "id"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/blogPosts/{blogPostId}",
        "definition": {
          "entityName": "BlogPost",
          "schema": {
            "$ref": "#/backend/entities/BlogPost"
          },
          "description": "Stores blog post data. The document ID serves as the blogPostId. Includes denormalized `authorId`.",
          "params": [
            {
              "name": "blogPostId",
              "description": "Unique identifier for the blog post."
            }
          ]
        }
      },
      {
        "path": "/authors/{authorId}",
        "definition": {
          "entityName": "Author",
          "schema": {
            "$ref": "#/backend/entities/Author"
          },
          "description": "Stores author data. The document ID serves as the authorId.",
          "params": [
            {
              "name": "authorId",
              "description": "Unique identifier for the author."
            }
          ]
        }
      },
      {
        "path": "/tags/{tagId}",
        "definition": {
          "entityName": "Tag",
          "schema": {
            "$ref": "#/backend/entities/Tag"
          },
          "description": "Stores tag data. The document ID serves as the tagId.",
          "params": [
            {
              "name": "tagId",
              "description": "Unique identifier for the tag."
            }
          ]
        }
      },
      {
        "path": "/siteConfiguration/{configId}",
        "definition": {
          "entityName": "SiteConfiguration",
          "schema": {
            "$ref": "#/backend/entities/SiteConfiguration"
          },
          "description": "Stores site-wide configuration settings. There should only be one document in this collection with the ID 'siteConfig'.",
          "params": [
            {
              "name": "configId",
              "description": "Unique identifier for the site configuration. Should ideally be 'siteConfig'."
            }
          ]
        }
      },
      {
        "path": "/roles_admin/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/Author"
          },
          "description": "Collection to store UIDs of admin users. Existence of a document with the user's UID grants admin privileges. No data needs to be stored in the document itself.",
          "params": [
            {
              "name": "userId",
              "description": "The UID of the admin user."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to support a blog website with admin-controlled blog posts and site-wide configurations. It prioritizes authorization independence and clear security rules.  The structure segregates data based on access patterns. Blog posts are stored in the `blogPosts` collection. Authors are stored in `authors`. Tags are stored in `tags`.  Site-wide configuration is stored in `siteConfiguration`.  Admin access is determined by membership in the `/roles_admin/{uid}` collection. This design ensures authorization independence, simplifies security rules, and supports the required application features.\n\n**Authorization Independence:** The structure avoids hierarchical authorization dependencies by storing all necessary data at the document level.\n\n**QAPs Support:**\n*   **List Operations:** The flat structure of `blogPosts` and other collections enables secure and efficient `list` operations with simple queries.\n*   **Admin Role:** The `roles_admin` collection provides a simple and efficient way to verify admin privileges without needing to read document data during authorization."
  }
}